<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Clean 3D Shape Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    height: 100vh;
    display: flex;
    background: #020617;
    color: white;
    font-family: Arial, sans-serif;
}

/* Sidebar */
.sidebar {
    width: 240px;
    padding: 20px;
    border-right: 1px solid #1e293b;
    box-sizing: border-box;
}

.sidebar h2 {
    text-align: center;
    margin-top: 0;
}

.sidebar button {
    width: 100%;
    padding: 10px;
    margin: 6px 0;
    background: #2563eb;
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
}

.sidebar label {
    display: block;
    margin-top: 20px;
}

.sidebar input {
    width: 100%;
}

/* Viewer */
.viewer {
    flex: 1;
}
canvas { display: block; }
</style>
</head>

<body>

<div class="sidebar">
    <h2>3D Shapes</h2>
    <button onclick="createCube()">Cube</button>
    <button onclick="createSphere()">Sphere</button>
    <button onclick="createPyramid()">Pyramid</button>

    <label>
        Rotation Speed
        <input type="range" min="0" max="0.05" step="0.001" value="0.01" id="speed">
    </label>
</div>

<div class="viewer" id="viewer"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let mesh, ring;
let speed = 0.01;
let isTransparent = false;
let currentShape = "cube";

/* Mouse-based rotation (user oriented) */
let targetRotX = 0;
let targetRotY = 0;

/* INIT */
init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    camera = new THREE.PerspectiveCamera(
        60,
        (window.innerWidth - 240) / window.innerHeight,
        0.1,
        100
    );
    camera.position.set(0, 0, 4);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth - 240, window.innerHeight);
    document.getElementById("viewer").appendChild(renderer.domElement);

    /* Lights */
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(3, 3, 3);
    scene.add(light);

    createCube();

    document.getElementById("speed").addEventListener("input", e => {
        speed = parseFloat(e.target.value);
    });

    renderer.domElement.addEventListener("mousemove", onMouseMove);
    renderer.domElement.addEventListener("click", toggleTransparency);
    renderer.domElement.addEventListener("dblclick", toggleRing);

    window.addEventListener("resize", onResize);
}

/* MATERIAL */
function material(color) {
    return new THREE.MeshStandardMaterial({
        color,
        metalness: 0.2,
        roughness: 0.6,
        transparent: true,
        opacity: 1
    });
}

/* CLEAR */
function clearShape() {
    if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        mesh = null;
    }
    if (ring) {
        scene.remove(ring);
        ring.geometry.dispose();
        ring.material.dispose();
        ring = null;
    }
    isTransparent = false;
}

/* SHAPES */
function createCube() {
    clearShape();
    currentShape = "cube";
    mesh = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        material(0x3b82f6)
    );
    scene.add(mesh);
}

function createSphere() {
    clearShape();
    currentShape = "sphere";
    mesh = new THREE.Mesh(
        new THREE.SphereGeometry(1, 32, 32),
        material(0x22d3ee)
    );
    scene.add(mesh);
}

function createPyramid() {
    clearShape();
    currentShape = "pyramid";
    mesh = new THREE.Mesh(
        new THREE.ConeGeometry(1, 1.8, 4),
        material(0xf97316)
    );
    scene.add(mesh);
}

/* INTERACTIONS */
function onMouseMove(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    const nx = (e.clientX - rect.left) / rect.width - 0.5;
    const ny = (e.clientY - rect.top) / rect.height - 0.5;

    targetRotY = nx * Math.PI;
    targetRotX = ny * Math.PI;
}

function toggleTransparency() {
    isTransparent = !isTransparent;
    mesh.material.opacity = isTransparent ? 0.4 : 1;
}

function toggleRing() {
    if (currentShape !== "sphere") return;

    if (ring) {
        scene.remove(ring);
        ring.geometry.dispose();
        ring.material.dispose();
        ring = null;
    } else {
        ring = new THREE.Mesh(
            new THREE.TorusGeometry(1.3, 0.07, 16, 80),
            material(0xe879f9)
        );
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);
    }
}

/* LOOP */
function animate() {
    requestAnimationFrame(animate);

    if (mesh) {
        mesh.rotation.x += (targetRotX - mesh.rotation.x) * speed;
        mesh.rotation.y += (targetRotY - mesh.rotation.y) * speed;
    }
    if (ring) {
        ring.rotation.z += speed * 0.5;
    }

    renderer.render(scene, camera);
}

/* RESIZE */
function onResize() {
    camera.aspect = (window.innerWidth - 240) / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth - 240, window.innerHeight);
}
</script>

</body>
</html>
